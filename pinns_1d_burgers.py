# -*- coding: utf-8 -*-
"""PINNs_1D_Burgers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NstmN8bljCdkq8XVX0J68W6G0UfkpB6i
"""

import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
import torch
import torch.nn as nn

# ---------------------- PINN Model Definition ---------------------- #
class BurgersPINN(nn.Module):
    def __init__(self):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(2, 20),
            nn.Tanh(),
            nn.Linear(20, 30),
            nn.Tanh(),
            nn.Linear(30, 30),
            nn.Tanh(),
            nn.Linear(30, 20),
            nn.Tanh(),
            nn.Linear(20, 20),
            nn.Tanh(),
            nn.Linear(20, 1)
        )
    def forward(self, x):
        return self.model(x)

# ---------------------- Physics-Informed Loss ---------------------- #
def compute_pde_residual(pinn, x, t, nu):
    x.requires_grad_(True)
    t.requires_grad_(True)
    X = torch.cat([x, t], dim=1)
    u = pinn(X)

    grads = torch.autograd.grad(u, x, grad_outputs=torch.ones_like(u), create_graph=True, retain_graph=True)[0]
    grads_t = torch.autograd.grad(u, t, grad_outputs=torch.ones_like(u), create_graph=True, retain_graph=True)[0]
    grads_xx = torch.autograd.grad(grads, x, grad_outputs=torch.ones_like(grads), create_graph=True, retain_graph=True)[0]

    f = grads_t + u * grads - nu * grads_xx
    return f

# ---------------------- Data Generation ---------------------- #
def initial_condition(x):
    return -torch.sin(np.pi * x)

def boundary_condition(t):
    return torch.zeros_like(t)

def sample_training_points(n_interior, n_boundary, n_initial):
    x_int = torch.rand(n_interior, 1) * 2 - 1   # [-1,1]
    t_int = torch.rand(n_interior, 1)

    x_bnd = torch.cat([torch.ones(n_boundary//2, 1) * -1, torch.ones(n_boundary//2, 1)], dim=0)
    t_bnd = torch.rand(n_boundary, 1)

    x_ini = torch.rand(n_initial, 1) * 2 - 1
    t_ini = torch.zeros(n_initial, 1)

    return (x_int, t_int), (x_bnd, t_bnd), (x_ini, t_ini)

# ---------------------- Training Loop ---------------------- #
def train_pinn(model, nu, epochs=3000, n_int=10000, n_bnd=2000, n_ini=2000, lr=1e-3):
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    losses = []

    for _ in tqdm(range(epochs)):
        (x_int, t_int), (x_bnd, t_bnd), (x_ini, t_ini) = sample_training_points(n_int, n_bnd, n_ini)
        X_int = torch.cat([x_int, t_int], dim=1)
        X_bnd = torch.cat([x_bnd, t_bnd], dim=1)
        X_ini = torch.cat([x_ini, t_ini], dim=1)

        # PDE loss (interior)
        f = compute_pde_residual(model, x_int, t_int, nu)
        loss_pde = torch.mean(f ** 2)

        # Initial condition loss
        u_ini_pred = model(X_ini)
        u_ini_true = initial_condition(x_ini)
        loss_ini = torch.mean((u_ini_pred - u_ini_true) ** 2)

        # Boundary loss
        u_bnd_pred = model(X_bnd)
        u_bnd_true = boundary_condition(t_bnd)
        loss_bnd = torch.mean((u_bnd_pred - u_bnd_true) ** 2)

        # Total loss
        total_loss = loss_pde + loss_ini + loss_bnd
        losses.append(total_loss.item())

        optimizer.zero_grad()
        total_loss.backward()
        optimizer.step()

    return losses

# ---------------------- Prediction Grid ---------------------- #
def make_prediction_grid(nx=256, nt=100):
    x_grid = torch.linspace(-1, 1, nx).reshape(-1, 1)
    t_grid = torch.linspace(0, 1, nt).reshape(-1, 1)
    X, T = torch.meshgrid(x_grid.squeeze(), t_grid.squeeze(), indexing='ij')
    X_flat = X.reshape(-1, 1)
    T_flat = T.reshape(-1, 1)
    X_full = torch.cat([X_flat, T_flat], dim=1)
    return X, T, X_full

# ---------------------- Main Routine ---------------------- #
if __name__ == "__main__":
    torch.manual_seed(0)
    nu = 0.01 / np.pi
    model = BurgersPINN()
    print("Training model...")
    train_pinn(model, nu, epochs=3000, n_int=10000, n_bnd=2000, n_ini=2000, lr=1e-3)
    print("Training complete.")

    # Predict over grid
    X, T, grid_inputs = make_prediction_grid()
    u_pred = model(grid_inputs).detach().cpu().numpy().reshape(X.shape)

    # Plot
    plt.figure(figsize=(8, 6))
    plt.pcolormesh(T, X, u_pred, shading='auto', cmap='jet')
    plt.xlabel('t')
    plt.ylabel('x')
    plt.colorbar(label='u(x, t)')
    plt.title('PINN Solution to 1D Burgers Equation')
    plt.show()

t_fixed = 0.5
x_values = torch.linspace(-1, 1, 200).reshape(-1, 1)
t_values = torch.ones_like(x_values) * t_fixed
X_query = torch.cat([x_values, t_values], dim=1)
y_pred = model(X_query).detach().cpu().numpy()  # shape: (200, 1)

plt.plot(x_values.numpy(), y_pred[:,0])
plt.xlabel('x')
plt.ylabel('u(x, t=0.5)')
plt.title('PINN Solution at t=0.5')
plt.show()

